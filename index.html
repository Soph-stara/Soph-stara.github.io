<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sophie Hamann</title>
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">

    <style>
        body {
            background-color: white;
            color: #e10600;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        h1, h2, h3 {
            font-weight: normal;
            margin-bottom: 0.5em;
        }

        a {
            color: #e10600;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Fabric background */
        #fabric-container {
            pointer-events: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* Content overlay */
        .content {
            position: relative;
            z-index: 1;
            background-color: rgba(255, 255, 255, 0.95);
            max-width: 800px;
            margin: 0 auto;
            padding: 40px;
            margin-top: 40px;
            margin-bottom: 40px;
        }

        /* Navigation */
        .navigation {
            margin-bottom: 60px;
        }

        .navigation a {
            margin-right: 20px;
        }

        /* Sections */
        .section {
            max-width: 700px;
            margin-bottom: 60px;
        }

        .muted {
            opacity: 0.7;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>

<body>
    <!-- Fabric simulation background -->
    <div id="fabric-container"></div>

    <!-- Main content -->
    <div class="content">
        <h1>Sophie Hamann</h1>

        <div class="navigation">
            <a href="cv.html">CV </a>
            <a href="caliban_landing_page.html">Caliban's Daughters  | </a>
            <a href="entropy_hope_landing.html">(Mad) Hope  | </a>
            <a href="algae.html">How Algae Can Change the World  | </a>
            <a href="mapping_commons.html">Mapping Commons  | </a>
            <a href="ode_to_our_mother.html">Ode to Our Mother  | </a>
        </div>

        <div class="section">
            <p class="muted">
                I am an interdisciplinary researcher and artist working across computation, feminist theory, and artistic research. My practice investigates how hidden systemscan be made perceptible through sensory, computational, and narrative methods. Moving between digital humanities, climate research, and artistic experimentation, I use tools such as data analysis, mapping, sonification, and interactive systems to translate complex structures into experiential forms. I am particularly interested in glitches, commons, and moments of instability as sites for knowledge production, care, and collective imagination.
            </p>
        </div>

        <div class="section">
            <h2>Projects</h2>
            <p>
                → <a href="caliban_landing_page.html">Caliban's Daughters</a><br>             
                → <a href="entropy_hope_landing.html">(Mad) Hope</a><br>             
                → <a href="algae.html">How Algae Can Change the World</a><br>
                → <a href="mapping_commons.html">Mapping Commons</a><br>
                → <a href="ode_to_our_mother.html">Ode to Our Mother</a>
            </p>
        </div>

        <div class="section muted">
            <p>
                Living and working in Vienna<br>
                <a href="mailto:sophiehamann.maxi@gmail.com">sophiehamann.maxi@gmail.com</a>
            </p>
        </div>
    </div>

    <script>
        // Fabric simulation
        let cols = 40;
        let rows = 40;
        let spacing = 15;
        
        let lineColor = [225, 6, 0, 100];  // Red with transparency
        let points = [];
        let gravity = 0.2;
        let damping = 0.98;
        let wave = 0;

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent('fabric-container');
            
            let offsetX = (width - (cols - 1) * spacing) / 2;
            let offsetY = (height - (rows - 1) * spacing) / 2;
            
            for (let y = 0; y < rows; y++) {
                points[y] = [];
                for (let x = 0; x < cols; x++) {
                    let fixed = (y === 0 || y === rows - 1 || x === 0 || x === cols - 1);
                    points[y][x] = {
                        x: offsetX + x * spacing,
                        y: offsetY + y * spacing,
                        prevX: offsetX + x * spacing,
                        prevY: offsetY + y * spacing,
                        fixed: fixed
                    };
                }
            }
        }

        function draw() {
            clear();            
            wave += 0.03;
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let p = points[y][x];
                    
                    if (!p.fixed) {
                        let vx = (p.x - p.prevX) * damping;
                        let vy = (p.y - p.prevY) * damping;
                        
                        p.prevX = p.x;
                        p.prevY = p.y;
                        
                        let waveForce = sin(wave + x * 0.2 + y * 0.2) * 0.3;
                        
                        p.x += vx + waveForce;
                        p.y += vy + gravity;
                        
                        let dx = mouseX - p.x;
                        let dy = mouseY - p.y;
                        let dist = sqrt(dx * dx + dy * dy);
                        
                        if (dist < 120) {
                            let force = (120 - dist) / 120;
                            p.x -= dx * force * 0.08;
                            p.y -= dy * force * 0.08;
                        }
                    }
                }
            }
            
            for (let i = 0; i < 5; i++) {
                applyConstraints();
            }
            
            stroke(lineColor[0], lineColor[1], lineColor[2], lineColor[3]);
            strokeWeight(0.8);
            noFill();
            
            for (let y = 0; y < rows; y++) {
                beginShape();
                for (let x = 0; x < cols; x++) {
                    let p = points[y][x];
                    if (x === 0) curveVertex(p.x, p.y);
                    curveVertex(p.x, p.y);
                    if (x === cols - 1) curveVertex(p.x, p.y);
                }
                endShape();
            }
            
            for (let x = 0; x < cols; x++) {
                beginShape();
                for (let y = 0; y < rows; y++) {
                    let p = points[y][x];
                    if (y === 0) curveVertex(p.x, p.y);
                    curveVertex(p.x, p.y);
                    if (y === rows - 1) curveVertex(p.x, p.y);
                }
                endShape();
            }
        }

        function applyConstraints() {
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let p1 = points[y][x];
                    
                    if (x < cols - 1) {
                        let p2 = points[y][x + 1];
                        constrainDistance(p1, p2, spacing);
                    }
                    
                    if (y < rows - 1) {
                        let p2 = points[y + 1][x];
                        constrainDistance(p1, p2, spacing);
                    }
                }
            }
        }

        function constrainDistance(p1, p2, targetDist) {
            let dx = p2.x - p1.x;
            let dy = p2.y - p1.y;
            let dist = sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                let diff = (targetDist - dist) / dist;
                let offsetX = dx * diff * 0.5;
                let offsetY = dy * diff * 0.5;
                
                if (!p1.fixed) {
                    p1.x -= offsetX;
                    p1.y -= offsetY;
                }
                
                if (!p2.fixed) {
                    p2.x += offsetX;
                    p2.y += offsetY;
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            
            let offsetX = (width - (cols - 1) * spacing) / 2;
            let offsetY = (height - (rows - 1) * spacing) / 2;
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    points[y][x].x = offsetX + x * spacing;
                    points[y][x].y = offsetY + y * spacing;
                    points[y][x].prevX = points[y][x].x;
                    points[y][x].prevY = points[y][x].y;
                }
            }
        }
    </script>
</body>
</html>