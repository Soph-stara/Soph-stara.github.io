<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sophie Hamann</title>
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">

    <style>
        body {
            background-color: white;

            color: #e10600;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        h1, h2, h3 {
            font-weight: normal;
            margin-bottom: 0.5em;
        }

        a {
            color: #e10600;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Main container */
        .container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px;
            gap: 60px;
            align-items: flex-start;
        }

        /* Content */
        .content {
            flex: 1;
            min-width: 400px;
        }

        /* Fabric visualization */
        #fabric-container {
            flex: 1;
            position: sticky;
            top: 120px; /* ‚Üê THIS moves it down on desktop */
            height: 600px;
        }

        /* Navigation */
        .navigation {
            margin-bottom: 60px;
        }

        .navigation a {
            margin-right: 20px;
        }

        /* Sections */
        .section {
            max-width: 700px;
            margin-bottom: 60px;
        }

        .muted {
            opacity: 0.7;
        }

        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            #fabric-container {
        position: relative;
        margin-top: 1000px;
        width: 100%;
        height: 400px;
    }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>

<body>
    <div class="container">
        <!-- Main content -->
        <div class="content">
            <h1>Sophie Hamann</h1>

            <div class="navigation">
                <a href="cv.html">CV</a>
                <a href="caliban_landing_page.html">Caliban's Daughters</a>
                <a href="entropy_hope_landing.html">(Mad) Hope</a>
                <a href="algae.html">How Algae Can Change the World</a>
                <a href="mapping_commons.html">Mapping Commons</a>
                <a href="ode_to_our_mother.html">Ode to Our Mother</a>
            </div>

            <div class="section">
                <p class="muted">
                    I am an interdisciplinary researcher and artist working across computation, feminist theory, and artistic research. My practice investigates how hidden systems can be made perceptible through sensory, computational, and narrative methods. Moving between digital humanities, climate research, and artistic experimentation, I use tools such as data analysis, mapping, sonification, and interactive systems to translate complex structures into experiential forms. I am particularly interested in glitches, commons, and moments of instability as sites for knowledge production, care, and collective imagination.
                </p>
            </div>

            <div class="section">
                <h2>Projects</h2>
                <p>
                    ‚Üí <a href="caliban_landing_page.html">Caliban's Daughters</a><br>             
                    ‚Üí <a href="entropy_hope_landing.html">(Mad) Hope</a><br>             
                    ‚Üí <a href="algae.html">How Algae Can Change the World</a><br>
                    ‚Üí <a href="mapping_commons.html">Mapping Commons</a><br>
                    ‚Üí <a href="ode_to_our_mother.html">Ode to Our Mother</a>
                </p>
            </div>

            <div class="section muted">
                <p>
                    Living and working in Vienna<br>
                    <a href="mailto:sophiehamann.maxi@gmail.com">sophiehamann.maxi@gmail.com</a>
                </p>
            </div>
        </div>

        <!-- Fabric simulation -->
        <div id="fabric-container"></div>
    </div>

    <script>
        // Fabric simulation
        let cols = 40;
        let rows = 40;
        let spacing = 15;
        
        let lineColor = [225, 6, 0, 100];
        let points = [];
        let gravity = 0.2;
        let damping = 0.98;
        let wave = 0;

        function setup() {
            let canvas = createCanvas(600, 600);
            canvas.parent('fabric-container');
            
            let offsetX = (600 - (cols - 1) * spacing) / 2;
            let offsetY = (600 - (rows - 1) * spacing) / 2;
            
            for (let y = 0; y < rows; y++) {
                points[y] = [];
                for (let x = 0; x < cols; x++) {
                    let fixed = (y === 0 || y === rows - 1 || x === 0 || x === cols - 1);
                    points[y][x] = {
                        x: offsetX + x * spacing,
                        y: offsetY + y * spacing,
                        prevX: offsetX + x * spacing,
                        prevY: offsetY + y * spacing,
                        fixed: fixed
                    };
                }
            }
        }

        function draw() {
            background(255, 255, 255, 30);
            wave += 0.04; // faster wave progression

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let p = points[y][x];

                    if (!p.fixed) {
                        let vx = (p.x - p.prevX) * damping;
                        let vy = (p.y - p.prevY) * damping;

                        p.prevX = p.x;
                        p.prevY = p.y;

                        // üåä Traveling wave (never settles)
                        let waveForceX = sin(wave + y * 0.3) * 0.4;
                        let waveForceY = cos(wave + x * 0.25) * 0.3;

                        // üå¨ Perpetual wind noise
                        let wind = sin(wave * 0.7 + x * 0.1) * 0.5;

                        p.x += vx + waveForceX + wind;
                        p.y += vy + gravity + waveForceY;

                        // üñ± Mouse interaction stays
                        let dx = mouseX - p.x;
                        let dy = mouseY - p.y;
                        let dist = sqrt(dx * dx + dy * dy);

                        if (dist < 120) {
                            let force = (120 - dist) / 120;
                            p.x -= dx * force * 0.1;
                            p.y -= dy * force * 0.1;
                        }
                    }
                }
            }

            for (let i = 0; i < 6; i++) {
                applyConstraints();
            }

            stroke(lineColor[0], lineColor[1], lineColor[2], lineColor[3]);
            strokeWeight(0.8);
            noFill();

            for (let y = 0; y < rows; y++) {
                beginShape();
                for (let x = 0; x < cols; x++) {
                    let p = points[y][x];
                    curveVertex(p.x, p.y);
                }
                endShape();
            }

            for (let x = 0; x < cols; x++) {
                beginShape();
                for (let y = 0; y < rows; y++) {
                    let p = points[y][x];
                    curveVertex(p.x, p.y);
                }
                endShape();
            }
        }

        function applyConstraints() {
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let p1 = points[y][x];
                    
                    if (x < cols - 1) {
                        let p2 = points[y][x + 1];
                        constrainDistance(p1, p2, spacing);
                    }
                    
                    if (y < rows - 1) {
                        let p2 = points[y + 1][x];
                        constrainDistance(p1, p2, spacing);
                    }
                }
            }
        }

        function constrainDistance(p1, p2, targetDist) {
            let dx = p2.x - p1.x;
            let dy = p2.y - p1.y;
            let dist = sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                let diff = (targetDist - dist) / dist;
                let offsetX = dx * diff * 0.5;
                let offsetY = dy * diff * 0.5;
                
                if (!p1.fixed) {
                    p1.x -= offsetX;
                    p1.y -= offsetY;
                }
                
                if (!p2.fixed) {
                    p2.x += offsetX;
                    p2.y += offsetY;
                }
            }
        }

        function windowResized() {
            // Canvas stays fixed size, no resize needed
        }
    </script>
</body>
</html>